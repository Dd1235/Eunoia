Problem: inserting a new todo at priority 1 violated the `(user_id, priority)` unique index → duplicate-key errors;
Solution: run `increment_priorities_for_user` first, which shifts every row by +1000 then renumbers back starting at 2, leaving slot 1 free. Problem: drag-and-drop sent `"["id1","id2"]"` (a JSON **string**) so `jsonb_array_elements_text()` threw “cannot extract elements from a scalar”; Solution: pass the raw array (no `JSON.stringify`) so Postgres receives a real `jsonb` array. Problem: subsequent reorder still hit duplicate priorities; Solution: three-phase SQL (`+1000`, set new 1…n, then compact leftovers) so the unique index is never violated inside the transaction. Problem: optimistic placeholder ids like `optimistic-123` failed `(value)::uuid` casts; Solution: generate syntactically correct UUIDs with `crypto.randomUUID()` or filter non-UUIDs before the RPC. Problem: checkbox clicks sometimes started a drag and the UI “snapped back”; Solution: `onPointerDown(e ⇒ e.stopPropagation())` on the checkbox/button **plus** an optimistic cache flip in `toggleTodo` to hide latency. Problem: delete button swallowed by DnD too; Solution: same pointer guard. Problem: cache briefly showed stale order/content after any mutation; Solution: use TanStack Query’s `onMutate / onError / onSuccess` pattern for all write paths. Overall learning: keep priorities dense only when needed (lazy re-balance during reorder), pass pure JSONB not double-stringified data, guard pointer events when mixing DnD with clicks, ensure every write happens inside a single SQL transaction (stored procedure) to satisfy the unique constraint at all intermediate steps, and always add an optimistic UI layer for a snappy experience.
